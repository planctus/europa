<?php
/**
 * @file
 * Code for the Announcement feature.
 */

include_once 'dt_announcement.features.inc';

/**
 * Implements hook_views_pre_render().
 *
 * Adds token support for see more views blocks.
 * You can use [node_title] in the read more text to have it replaced by the
 * node title.
 */
function dt_announcement_views_pre_render(&$view) {
  // On the listing, we alter the read more text to include our node title.
  if ($view->name == 'announcements' && $view->current_display == 'latest_block') {
    // Tokenize, resolved contextual filter check.
    // Inintialize our read more text variable.
    $read_more_text = $view->display_handler->default_display->options['use_more_text'];

    if (!empty($view->build_info['substitutions']['%1'])) {
      $read_more_text = str_replace('[node_title]', $view->build_info['substitutions']['%1'], $read_more_text);
    }

    // Alter the output to our custom text.
    $view->display_handler->default_display->options['use_more_text'] = $read_more_text;
  }
}

/**
 * Implements hook_views_query_alter().
 *
 * This query alteration will check if we are displaying the latest block. If we
 * do, then we get the argument node type, and all reference fields using this
 * node type.
 * For each field we have, we create a join to fetch the node id's. The sorting
 * used in views will be respected. We do however remove the contextual filter
 * as we do not want to filter on that in this case.
 */
function dt_announcement_views_query_alter(&$view, &$query) {
  // Set our conditional.
  $is_announcement_block = ($view->name == 'announcements' && $view->current_display == 'latest_block');
  $is_announcement_page = ($view->name == 'announcements' && $view->current_display == 'page_1');

  // Check if its the correct type and if the argument is set.
  if (($is_announcement_block || $is_announcement_page) && !empty($view->args[0])) {

    // Get our node type. And then call to our dt function.
    $node_type = _dt_announcement_get_node_type($view->args[0]);
    $fields_to_join = _dt_announcement_get_content_reference_fields($node_type);

    // Only apply our logic if we have fields to join.
    if (!empty($fields_to_join)) {

      // Remove our base condition.
      unset($query->where[0]['conditions'][0]);

      // Our "or" group.
      $db_or = db_or();

      // Loop our result and add the join.
      foreach ($fields_to_join as $key => $value) {

        // Alias.
        $alias = $node_type . '_node_' . $key;

        // Create the join object.
        $join_query = new views_join();
        $join_query->table = $value['data'];
        $join_query->field = 'entity_id';
        $join_query->left_table = 'node';
        $join_query->left_field = 'nid';
        $join_query->type = 'LEFT';

        // Add it to our query.
        $query->add_relationship(
          $alias,
          $join_query,
          'node'
        );

        // Add our conditions.
        $db_or->condition(
          $alias . '.' . $value['name'] . '_target_id',
          $view->args[0]
        );

      }

      // Add our or conditional.
      // Add the where condition, to filter our nodes.
      $query->add_where(
        'OR',
        $db_or
      );

    }
  }
  elseif (($is_announcement_block || $is_announcement_page) && empty($view->args[0])) {
    // When we dont have an argument filter, we hide the header text.
    unset($view->header['area_text_custom']);
  }
}

/**
 * Helper function to get the available entity reference fields.
 *
 * This function get's all entity reference fields that reference the content
 * type and are available on the announcement content type.
 */
function _dt_announcement_get_content_reference_fields($node_type) {
  // Inintialize variables.
  $field_join_list = array();
  $counter = 0;

  // Our full group name defenition.
  $group_name = 'group_announcement_related|node|announcement|form';

  // Get our cached ctools export object. We use the field_group function for
  // this at it gives us a clean response.
  $field_group = field_group_load_field_group('group_announcement_related', 'node', 'announcement', 'form');

  // Get the full list of entity reference fields.
  $available_fields = field_info_fields();

  // Loop all the available fields.
  foreach ($available_fields as $field_name => $field_data) {
    // Check only entityreference fields.
    if ($field_data['type'] == 'entityreference') {
      // And those that target our node type.
      if (!empty($field_data['settings']['handler_settings']['target_bundles'][$node_type])) {
        // Then if they are in our group, we include them.
        if (in_array($field_name, $field_group->children)) {
          // Add the data to our array.
          $field_join_list[$counter]['data'] = 'field_data_' . $field_name;
          $field_join_list[$counter]['name'] = $field_name;
          $counter++;
        }
      }
    }
  }

  // Return the data we have.
  return $field_join_list;
}

/**
 * Helper function to get the node type.
 *
 * Simple database query to get the node type from a node id. We do it this way
 * because now we can avoid a heavy node_load.
 */
function _dt_announcement_get_node_type($nid) {
  return db_query("SELECT type FROM {node} WHERE nid=:nid",
    array(':nid' => $nid))->fetchField();
}
