<?php
/**
 * @file
 * Code for the Core feature.
 */

include_once 'dt_core.features.inc';
class DTCoreSourceFieldError extends Exception {};
class DTCoreDestinationFieldError extends Exception {};
class DTCoreFieldTypeAreNotSame extends Exception {};
class DTCoreParentCircular extends Exception {};

/**
 * Implements hook_field_widget_form_alter().
 */
function dt_core_field_widget_form_alter(&$element, &$form_state, $context) {
  if ($context['field']['type'] == 'entityreference') {
    if ($context['field']['settings']['target_type'] == 'node' && !empty($context['field']['settings']['handler_settings']['target_bundles'])) {
      $types = $context['field']['settings']['handler_settings']['target_bundles'];
      $types_count = count($types);
      $links = '';
      $i = 0;
      $separator = ',';
      foreach ($types as $machine_name) {
        $type = node_type_get_type($machine_name);
        $current_separator = $types_count > 1 && $i == $types_count - 2 ? ' ' . t('or') : $separator;
        $links .= l($type->name, 'node/add/' . str_replace('_', '-', $machine_name), array('attributes' => array('target' => '_blank'))) . $current_separator . ' ';
        $i++;
      }
      $links = rtrim($links, $separator . ' ');
      $description = '<p>' . t('In case the content you try to refer to does not exist yet you can create it by going to !links.', array('!links' => $links)) . '</p>';
      if (isset($element['target_id'])) {
        $element['target_id']['#description'] = $description . $element['target_id']['#description'];
      }
      else {
        $element['#description'] = $description . $element['#description'];
      }
    }
  }
}

/**
 * Implements hook_block_info().
 */
function dt_core_block_info() {
  $blocks['dt_block_copyright'] = array(
    'info' => t('Copyright paragraph'),
  );

  $blocks['dt_header_site_tab_switcher'] = array(
    'info' => t('Header site tab switcher'),
  );

  $blocks['dt_footer_site_tab_switcher'] = array(
    'info' => t('Footer site tab switcher'),
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function dt_core_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'dt_block_copyright':
    case 'dt_header_site_tab_switcher':
    case 'dt_footer_site_tab_switcher':
      $block['content'] = dt_core_get_blocks_content($delta);
      break;
  }
  return $block;
}

/**
 * A module-defined block content function.
 */
function dt_core_get_blocks_content($delta) {
  $result = array();
  switch ($delta) {
    case 'dt_block_copyright':
      $result = array(
        '#markup' => "<div class='footer__disclaimer'><span>" . t('Â© European Commission 2015') . "</span></div>",
      );
      break;

    case 'dt_header_site_tab_switcher':
      $result = array(
        '#markup' => theme('site_switcher_tabs', array('modifier' => 'site-switcher--header')),
      );
      break;

    case 'dt_footer_site_tab_switcher':
      $result = array(
        '#markup' => theme('site_switcher_tabs', array('modifier' => 'site-switcher--footer')),
      );
      break;
  }
  return $result;
}

/**
 * Implements hook_theme().
 */
function dt_core_theme($existing, $type, $theme, $path) {
  return array(
    'site_switcher_tabs' => array(
      'file' => 'dt_core.theme.inc',
      'variables' => array(
        'modifier' => NULL,
      ),
    ),
  );
}

/**
 * Helper to add initial set of buttons on the default profile of the Full HTML.
 */
function dt_apply_wysiwyg_buttons() {
  // Enable a set of CKEditor buttons for DT project on the "Full HTML" profile.
  $default = array(
    'Anchor',
    'Bold',
    'Italic',
    'Underline',
    'Format',
    'JustifyBlock',
    'JustifyCenter',
    'JustifyLeft',
    'JustifyRight',
    'Indent',
    'Outdent',
    'Blockquote',
    'Font',
    'Table',
    'BulletedList',
    'NumberedList',
    'Link',
    'Unlink',
    'Source',
    'PasteFromWord',
    'Undo',
    'ShowBlocks',
  );
  multisite_config_service('wysiwyg')->addButtonsToProfile('full_html', 'default', $default);

  $lite = array(
    'lite_AcceptAll',
    'lite_RejectOne',
    'lite_RejectAll',
    'lite_ToggleShow',
    'lite_AcceptOne',
    'lite_ToggleTracking',
  );
  multisite_config_service('wysiwyg')->addButtonsToProfile('full_html', 'lite', $lite);
}

/**
 * Copy values from source to destination filed.
 *
 * @param string $entity_type
 *   the type of entity, like: node.
 * @param string $bundle
 *   entity bundle, like: page.
 * @param string $source_field_name
 *   source field name, like: field_core_link.
 * @param string $destination_field_name
 *   destination field, like: field_core_links.
 *
 * @throws \DTCoreSourceFieldError
 *   Exception when no source field with the given name.
 * @throws \DTCoreDestinationFieldError
 *   Exception when no destination field with the given name.
 * @throws \DTCoreFieldTypeAreNotSame
 *   Exception when source and destination are not the same field type.
 */
function _dt_core_field_value_copy($entity_type, $bundle, $source_field_name, $destination_field_name) {
  // Source and destination field info.
  $source_field_info = field_info_field($source_field_name);
  $destination_field_info = field_info_field($destination_field_name);

  // Error handling.
  if (!$source_field_info) {
    throw new DTCoreSourceFieldError(
      t('There is not any %source (source field) with this name.', array(
        '%source' => $source_field_name,
      ))
    );
  }
  if (!$destination_field_info) {
    throw new DTCoreDestinationFieldError(
      t('There is not any %source (source field) with this name.', array(
        '%source' => $destination_field_name,
      ))
    );
  }
  if ($source_field_info['type'] != $destination_field_info['type']) {
    throw new DTCoreFieldTypeAreNotSame(
      t('%source (source) and %destination (destination) are not the same field type.', array(
        '%source' => $source_field_name,
        '%destination' => $destination_field_name,
      ))
    );
  }
  // Source field  is a multiple one.
  $source_field_is_multiple = ($source_field_info['cardinality'] != 1) ? TRUE : FALSE;
  // Destination field is a multiple one.
  $destination_field_is_multiple = ($destination_field_info['cardinality'] != 1) ? TRUE : FALSE;

  // Query the entities.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $entity_type)
    ->entityCondition('bundle', $bundle);
  $result = $query->execute();

  // Use the result if any.
  if (isset($result[$entity_type])) {
    // Get the entity ids from result.
    $ids = array_keys($result[$entity_type]);
    // Load entities using ids.
    $entities = entity_load($entity_type, $ids, array(), TRUE);
    foreach ($entities as $entity) {
      $entity_wrapper = entity_metadata_wrapper($entity_type, $entity);

      // Check the source field for value.
      if (
        isset($entity_wrapper->$source_field_name)
        && $entity_wrapper->$source_field_name->value()
        && $entity_wrapper->$destination_field_name->value() == NULL
      ) {
        // Same cardinality.
        if ($source_field_is_multiple == $destination_field_is_multiple) {
          $entity_wrapper->$destination_field_name = $entity_wrapper->$source_field_name->value();
        }
        // Source is multiple field, but destination not,
        // than take the first element.
        elseif ($source_field_is_multiple && !$destination_field_is_multiple) {
          $entity_wrapper->$destination_field_name = reset($entity_wrapper->$source_field_name->value());
        }
        // Source is single element field, but destination not,
        // than use an array wrapper.
        else {
          // Take the first item of array.
          $entity_wrapper->$destination_field_name = array($entity_wrapper->$source_field_name->value());
        }
        $entity_wrapper->save();
      }
    }
  }
}

/**
 * Nodes that will have their alias re-generated on hook_exit().
 */
$GLOBALS['dt_core_nodes_to_update_alias'] = array();

/**
 * Fields that can be used in URL patterns to define hierarchy.
 */
$GLOBALS['dt_core_parent_fields'] = array(
  'field_core_parent',
  'field_core_policy_area',
);

/**
 * Implements function hook_path_insert().
 */
function dt_core_path_insert($path) {
  _dt_core_path_update_relatives($path);
}

/**
 * Implements function hook_path_update().
 */
function dt_core_path_update($path) {
  _dt_core_path_update_relatives($path);
}

/**
 * Updates aliases of parent | child nodes.
 */
function _dt_core_path_update_relatives($path) {
  $source = explode('/', $path['source']);
  if ($source[0] == 'node') {
    $nid = $source[1];

    foreach ($GLOBALS['dt_core_parent_fields'] as $field_name) {
      // Find children based on field.
      $children = _dt_core_node_get_relatives($nid, $field_name);
      // Add current as first to force re-generate as first.
      if (!empty($parents)) {
        array_unshift($children, $nid);
      }

      // Find parents based on field.
      $parents = _dt_core_node_get_relatives($nid, $field_name, 'parents', TRUE);
      // Add current as last to force re-generate as last.
      if (!empty($parents)) {
        $parents[] = $nid;
      }

      $relatives = array_merge($parents, $children);
      if (!empty($relatives)) {
        $GLOBALS['dt_core_nodes_to_update_alias'][$nid] = $relatives;
      }
    }
  }
}

/**
 * Finds child|parent nodes based on entity reference.
 *
 * Only a few entity reference fields can be used to define parent relationship.
 * These fields are stored in the $GLOBALS['dt_core_parent_fields'].
 *
 * @param int $nid
 *   Node id
 * @param string $field_name
 *   field name that is used for hierarchy
 * @param string $direction
 *   children or parents
 * @param bool $no_alias_only
 *   Exclude nodes that already have an alias.
 * @param int $original_nid
 *   Node id of the starting item
 *
 * @return array
 *   Node ids of children|parents
 *
 * @see $GLOBALS['dt_core_parent_fields']
 */
function _dt_core_node_get_relatives($nid, $field_name, $direction = 'children', $no_alias_only = FALSE, $original_nid = NULL) {
  if (!isset($field_name)) {
    return array();
  }
  $original_nid = !$original_nid ? $nid : $original_nid;
  $affected_nodes = array();

  if ($direction == 'parents') {
    $result = db_select('field_data_' . $field_name, 'p')
    ->fields('p', array($field_name . '_target_id'))
    ->condition('entity_id', $nid, '=')
    ->execute()
    ->fetchAssoc();

    $nids = $result ? array_values($result) : FALSE;
    // Check if parent has already an alias.
    if ($nids) {
      if ($no_alias_only && drupal_get_path_alias('node/' . $nids[0]) != ('node/' . $nids[0])) {
        return array();
      }

      // Item is among its own parents.
      if (in_array($original_nid, $nids)) {
        throw new DTCoreParentCircular(
          t('Node !nid is among its own parents', array(
            '!nid' => $original_nid,
          ))
        );
      }
    }
  }
  // Children need to be updated always.
  else {
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->fieldCondition($field_name, 'target_id', $nid, '=');

    $result = $query->execute();
    $nids = isset($result['node']) ? array_keys($result['node']) : FALSE;
  }

  if ($nids) {
    foreach ($nids as $ref_nid) {
      if (isset($result['node'][$ref_nid])) {
        // URL pattern for node type.
        $pattern = pathauto_pattern_load_by_entity('node', $result['node'][$ref_nid]->type);
        // If current child URL is not using the field in alias pattern, skip.
        if (!_dt_core_parent_field_in_pattern($field_name, $pattern)) {
          continue;
        }
      }

      // Find relatives.
      $referenced = _dt_core_node_get_relatives($ref_nid, $field_name, $direction, $no_alias_only, $original_nid);
      // Add the to the list in the appropriate order based on direction.
      if ($direction == 'parents') {
        $affected_nodes = array_merge($affected_nodes, $referenced);
        $affected_nodes[] = $ref_nid;
      }
      else {
        $affected_nodes[] = $ref_nid;
        $affected_nodes = array_merge($affected_nodes, $referenced);
      }
    }
  }

  return $affected_nodes;
}

/**
 * Implements function hook_exit().
 */
function dt_core_exit() {
  if (empty($GLOBALS['dt_core_nodes_to_update_alias']) || !is_array($GLOBALS['dt_core_nodes_to_update_alias'])) {
    return;
  }

  $nids_to_update = $GLOBALS['dt_core_nodes_to_update_alias'];
  $GLOBALS['dt_core_nodes_to_update_alias'] = array();
  foreach ($nids_to_update as $nid => $relatives) {
    // Paths update using the update method of the pathauto module.
    // Doing it one by one instead of using
    // pathauto_node_update_alias_multiple() to keep the order of items intact.
    foreach ($relatives as $rel_nid) {
      $node = node_load($rel_nid);
      pathauto_node_update_alias($node, 'update');
    }
  }
}

/**
 * Implements hook_pathauto_alias_alter().
 */
function dt_core_pathauto_alias_alter(&$alias, array &$context) {
  // Remove duplicates that are a result of a prefix defined in th URL pattern.
  // before the parent fields slug.
  //
  // For example:
  // The pattern "prefix/[parent:url]/[title]" might result in an alias like
  // "prefix/prefix/parent-title/title" if parent is of the same type since the
  // prefix is added twice. We will remove the duplicate prefix now.

  // We consider everything before the first token a prefix.
  $pattern_prefix = explode('[', $context['pattern']);
  $prefix = $pattern_prefix[0];

  if (!empty($prefix)) {
    // Check if it is subject of parent field.
    foreach ($GLOBALS['dt_core_parent_fields'] as $field_name) {
      // If the URL pattern does rely on this field remove duplicate prefix.
      if (_dt_core_parent_field_in_pattern($field_name, $context['pattern'])) {
        $alias = str_replace($prefix . $prefix, $prefix, $alias);
      }
    }
  }
}

/**
 * Checks if a URL pattern is relying on a parent field.
 *
 * @param string $field_name
 *   Field name
 *
 * @return mixed
 *   string pattern token segment | bool FALSE
 */
function _dt_core_parent_field_in_pattern($field_name, $pattern) {
  // Check if URL pattern uses parent's URL.
  $pattern_segment = 'node:' . str_replace('_', '-', $field_name) . ':url:path';
  if (preg_match('/' . $pattern_segment . '/', $pattern)) {

    return $pattern_segment;
  }

  return FALSE;
}

/**
 * Implements hook_node_validate().
 */
function dt_core_node_validate($node, $form, &$form_state) {
  $wrapper = entity_metadata_wrapper('node', $node);
  foreach ($GLOBALS['dt_core_parent_fields'] as $field_name) {
    if (isset($wrapper->{$field_name}) && $parent = $wrapper->{$field_name}->value()) {
      // Detect if node has been set as its own parent.
      if ($parent->nid == $node->nid) {
        form_set_error($field_name, t('The page cannot be its own parent!'));
      }
      // Detect circular reference between two nodes.
      if (_dt_core_detect_circular_reference($node)) {
        form_set_error($field_name, t('There is a circular reference between this page and one of its parent!'));
      }
    }
  }
}

/**
 * Checks if a URL pattern is relying on a parent field.
 *
 * @param object $node
 *   Node
 *
 * @return bool
 *   There is a circular reference between the two nodes.
 */
function _dt_core_detect_circular_reference($node) {
  $relatives = array();
  try {
    foreach ($GLOBALS['dt_core_parent_fields'] as $field_name) {
      $relatives += _dt_core_node_get_relatives($node->nid, $field_name, $direction = 'parents');
    }
  }
  catch (DTCoreParentCircular $e) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Helper function for creating a taxonomy term in a vocabulary.
 *
 * @param string $vocabulary_machine_name
 *   Vocabulary machine name.
 * @param string $term_name
 *   Added term.
 *
 * @return bool
 *   Return TRUE if the taxonomy term was created.
 */
function _dt_core_create_taxonomy_term($vocabulary_machine_name, $term_name) {
  // Check the vocabulary if exist.
  if ($vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_machine_name)) {
    // Creating term.
    $term = array();
    $term['vocabulary_machine_name'] = $vocabulary_machine_name;
    $term['vid'] = $vocabulary->vid;
    $term['name'] = $term_name;
    // Save term as an entity.
    $entity = entity_create('taxonomy_term', $term);
    return entity_save('taxonomy_term', $entity);
  }
  return FALSE;
}

/**
 * Migrate existing field content from language "undefined" to entity language.
 *
 * @param string $field_name
 *   Field to enable entity translation on.
 */
function _dt_core_enable_entity_translation($field_name, &$sandbox) {
  $context = array('sandbox' => &$sandbox);
  module_load_include('inc', 'entity_translation', 'entity_translation.admin');
  entity_translation_translatable_switch(TRUE, $field_name);
  entity_translation_translatable_batch(TRUE, $field_name, TRUE, $context);
  $sandbox['#finished'] = $context['finished'];
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function dt_core_form_locale_languages_overview_form_alter(&$form, &$form_state) {
  // Increase the range of weights that can be assigned to languages in the
  // languages overview form. By default the languages can only be sorted using
  // the range -10 to +10 but since we have 24 languages this is not sufficient.
  foreach (element_children($form['weight']) as $key) {
    $form['weight'][$key]['#delta'] = 20;
  }
}

/**
 * Helper function to enable languages.
 *
 * @param array $languages
 *   Language codes of languages to be enabled.
 */
function _dt_core_enable_lanugages($languages = array()) {
  module_load_include('inc', 'locale', 'locale.admin');
  $form_state = array();
  foreach ($languages as $key => $langcode) {
    // Enable language.
    multisite_config_service('locale')->addLanguage($langcode);
    // Set the appropriate weight for languages to follow the order defined in
    // the array.
    $form_state['values']['weight'][$langcode] = -20 + $key;

    // Portuguese exception:
    // In Drupal the "pt" prefix belongs to Portuguese / International but we
    // need Portuguese / Portugal to have this prefix (theme_image_style has "pt-pt" as
    // default prefix). We need to change this to "pt".
    if ($langcode == 'pt-pt') {
      db_update('languages')
        ->fields(array(
          'name' => 'Portuguese',
          'prefix' => 'pt',
        ))
        ->condition('language', $langcode)
        ->execute();
    }
  }
  // Save the order through the original form.
  drupal_form_submit('locale_languages_overview_form', $form_state);
  // Enable URL suffix based language negotiation.
  multisite_config_service('locale')->setLanguageNegotiation('nexteuropa_multilingual_url_suffix');
}

/**
 * Implements hook_node_presave().
 *
 * If a whitespace has been entered after a title, we remove it.
 */
function dt_core_node_presave($node) {
  $node->title = rtrim($node->title);
}
