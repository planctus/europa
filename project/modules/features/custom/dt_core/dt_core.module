<?php
/**
 * @file
 * Code for the Core feature.
 */

include_once 'dt_core.features.inc';
class DTCoreSourceFieldError extends Exception {};
class DTCoreDestinationFieldError extends Exception {};
class DTCoreFieldTypeAreNotSame extends Exception {};

/**
 * Implements hook_field_widget_form_alter().
 */
function dt_core_field_widget_form_alter(&$element, &$form_state, $context) {
  if ($context['field']['type'] == 'entityreference') {
    if ($context['field']['settings']['target_type'] == 'node' && !empty($context['field']['settings']['handler_settings']['target_bundles'])) {
      $types = $context['field']['settings']['handler_settings']['target_bundles'];
      $types_count = count($types);
      $links = '';
      $i = 0;
      $separator = ',';
      foreach ($types as $machine_name) {
        $type = node_type_get_type($machine_name);
        $current_separator = $types_count > 1 && $i == $types_count - 2 ? ' ' . t('or') : $separator;
        $links .= l($type->name, 'node/add/' . str_replace('_', '-', $machine_name), array('attributes' => array('target' => '_blank'))) . $current_separator . ' ';
        $i++;
      }
      $links = rtrim($links, $separator . ' ');
      $description = '<p>' . t('In case the content you try to refer to does not exist yet you can create it by going to !links.', array('!links' => $links)) . '</p>';
      if (isset($element['target_id'])) {
        $element['target_id']['#description'] = $description . $element['target_id']['#description'];
      }
      else {
        $element['#description'] = $description . $element['#description'];
      }
    }
  }
}

/**
 * Implements hook_block_info().
 */
function dt_core_block_info() {
  $blocks['dt_block_copyright'] = array(
    'info' => t('Copyright paragraph'),
  );

  $blocks['dt_block_footer_site_switcher'] = array(
    'info' => t('Footer Site switcher'),
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function dt_core_block_view($delta = '') {
  switch ($delta) {
    case 'dt_block_copyright':
    case 'dt_block_footer_site_switcher':
      $block['content'] = dt_core_get_blocks_content($delta);
      break;
  }
  return $block;
}

/**
 * A module-defined block content function.
 */
function dt_core_get_blocks_content($delta) {
  switch ($delta) {
    case 'dt_block_copyright':
      $license_link = l(t('EC license name'), '#');
      $result = array(
        '#markup' => "<div class='footer__disclaimer'><span>" . t('Â© European Commission copyright.') . "</span><span>" . t('All content available under') . ' ' . $license_link . "</span></div>",
      );
      return $result;

    case 'dt_block_footer_site_switcher':
      $result = array(
        '#markup' => l(
          t('<span>The European Commission </span><span>and its priorities</span>'),
          t('http://ec.europa.eu/index_en.htm'),
          array(
            'attributes' => array(
              'class' => array(
                'site-switcher', 'footer__site-switcher',
              ),
            ),
            'html' => TRUE,
          )
        ),
      );
      return $result;
  }
}

/**
 * Helper to add initial set of buttons on the default profile of the Full HTML.
 */
function dt_apply_wysiwyg_buttons() {
  // Enable a set of CKEditor buttons for DT project on the "Full HTML" profile.

  $default = array(
    'Anchor',
    'Bold',
    'Italic',
    'Underline',
    'Format',
    'JustifyBlock',
    'JustifyCenter',
    'JustifyLeft',
    'JustifyRight',
    'Indent',
    'Outdent',
    'Blockquote',
    'Font',
    'Table',
    'BulletedList',
    'NumberedList',
    'Link',
    'Unlink',
    'Source',
    'PasteFromWord',
    'Undo',
    'ShowBlocks',
  );
  multisite_config_service('wysiwyg')->addButtonsToProfile('full_html', 'default', $default);

  $lite = array(
    'lite_AcceptAll',
    'lite_RejectOne',
    'lite_RejectAll',
    'lite_ToggleShow',
    'lite_AcceptOne',
    'lite_ToggleTracking',
  );
  multisite_config_service('wysiwyg')->addButtonsToProfile('full_html', 'lite', $lite);
}

/**
 * Copy values from source to destination filed.
 *
 * @param string $entity_type
 *   the type of entity, like: node.
 * @param string $bundle
 *   entity bundle, like: page.
 * @param string $source_field_name
 *   source field name, like: field_core_link.
 * @param string $destination_field_name
 *   destination field, like: field_core_links.
 *
 * @throws \DTCoreSourceFieldError
 *   Exception when no source field with the given name.
 * @throws \DTCoreDestinationFieldError
 *   Exception when no destination field with the given name.
 * @throws \DTCoreFieldTypeAreNotSame
 *   Exception when source and destination are not the same field type.
 */
function _dt_core_field_value_copy($entity_type, $bundle, $source_field_name, $destination_field_name) {
  // Source and destination field info.
  $source_field_info = field_info_field($source_field_name);
  $destination_field_info = field_info_field($destination_field_name);

  // Error handling.
  if (!$source_field_info) {
    throw new DTCoreSourceFieldError(
      t('There is not any %source (source field) with this name.', array(
        '%source' => $source_field_name,
      ))
    );
  }
  if (!$destination_field_info) {
    throw new DTCoreDestinationFieldError(
      t('There is not any %source (source field) with this name.', array(
        '%source' => $destination_field_name,
      ))
    );
  }
  if ($source_field_info['type'] != $destination_field_info['type']) {
    throw new DTCoreFieldTypeAreNotSame(
      t('%source (source) and %destination (destination) are not the same field type.', array(
        '%source' => $source_field_name,
        '%destination' => $destination_field_name,
      ))
    );
  }
  // Source field  is a multiple one.
  $source_field_is_multiple = ($source_field_info['cardinality'] != 1) ? TRUE : FALSE;
  // Destination field is a multiple one.
  $destination_field_is_multiple = ($destination_field_info['cardinality'] != 1) ? TRUE : FALSE;

  // Query the entities.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $entity_type)
    ->entityCondition('bundle', $bundle);
  $result = $query->execute();

  // Use the result if any.
  if (isset($result[$entity_type])) {
    // Get the entity ids from result.
    $ids = array_keys($result[$entity_type]);
    // Load entities using ids.
    $entities = entity_load($entity_type, $ids, array(), TRUE);
    foreach ($entities as $entity) {
      $entity_wrapper = entity_metadata_wrapper($entity_type, $entity);

      // Check the source field for value.
      if (
        isset($entity_wrapper->$source_field_name)
        && $entity_wrapper->$source_field_name->value()
        && $entity_wrapper->$destination_field_name->value() == NULL
      ) {
        // Same cardinality.
        if ($source_field_is_multiple == $destination_field_is_multiple) {
          $entity_wrapper->$destination_field_name = $entity_wrapper->$source_field_name->value();
        }
        // Source is multiple field, but destination not,
        // than take the first element.
        elseif ($source_field_is_multiple && !$destination_field_is_multiple) {
          $entity_wrapper->$destination_field_name = reset($entity_wrapper->$source_field_name->value());
        }
        // Source is single element field, but destination not,
        // than use an array wrapper.
        else {
          // Take the first item of array.
          $entity_wrapper->$destination_field_name = array($entity_wrapper->$source_field_name->value());
        }
        $entity_wrapper->save();
      }
    }
  }
}

/**
 *
 */
$GLOBALS['nodes_to_update_alias'] = array();

/**
 * Implements function hook_path_insert().
 */
function dt_core_path_insert($path) {
  dt_core_path_update_relatives($path);
}

/**
 * Implements function hook_path_update().
 */
function dt_core_path_update($path) {
  dt_core_path_update_relatives($path);
}

/**
 * Updates aliases of referenced nodes.
 */
function dt_core_path_update_relatives($path) {
  $source = explode('/', $path['source']);
  if ($source[0] == 'node') {
    $nid = $source[1];

    // Find children based on field_core_parent.
    $children = _dt_core_node_get_relatives($nid);

    // Find parents based on field_core_parent.
    $parents = _dt_core_node_get_relatives($nid, 'parents', TRUE);

    $GLOBALS['nodes_to_update_alias'] = array_merge($children, $parents);
    watchdog('dt_core', serialize($GLOBALS['nodes_to_update_alias']), array(), WATCHDOG_NOTICE);
  }
}

/**
 * Finds child|parent nodes based on field_core_parent reference.
 *
 * @param int $nid
 *   Node id
 * @param string $direction
 *   children or parents
 * @param bool $no_alias_only
 *   Exclude nodes that already have an alias.
 *
 * @return array
 *   Node ids of children|parents
 */
function _dt_core_node_get_relatives($nid, $direction = 'children', $no_alias_only = FALSE) {
  $affected_nodes = array();

  if ($direction == 'parents') {
    $result = db_select('field_data_field_core_parent', 'p')
    ->fields('p', array('field_core_parent_target_id'))
    ->condition('entity_id', $nid, '=')
    ->execute()
    ->fetchAssoc();

    $nids = $result ? array_values($result) : FALSE;
  }
  else {
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->fieldCondition('field_core_parent', 'target_id', $nid, '=');

    $result = $query->execute();
    $nids = isset($result['node']) ? array_keys($result['node']) : FALSE;
  }

  if ($nids) {
    foreach ($nids as $ref_nid) {
      $affected_nodes[] = $ref_nid;
      if ($referenced = _dt_core_node_get_relatives($ref_nid, $direction, $no_alias_only)) {
        $affected_nodes = array_merge($affected_nodes, $referenced);
      }
    }
  }

  return array_unique($affected_nodes);
}

/**
 * Implements function hook_exit().
 */
function dt_core_exit() {
  if (empty($GLOBALS['nodes_to_update_alias']) || !is_array($GLOBALS['nodes_to_update_alias'])) {
    return;
  }

  $nids_to_update = $GLOBALS['nodes_to_update_alias'];
  $GLOBALS['nodes_to_update_alias'] = array();

  // Paths update using the multi update method of the pathauto module.
  pathauto_node_update_alias_multiple($nids_to_update, 'update');
  watchdog('dt_core', serialize($nids_to_update), array(), WATCHDOG_ERROR);
}
