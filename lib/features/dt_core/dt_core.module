<?php
/**
 * @file
 * Code for the Core feature.
 */

// Our global views tag.
define("DT_CORE_VIEWS_TAG", "digital_transformation");

// Nodes that will have their alias re-generated on hook_exit().
$GLOBALS['dt_core_nodes_to_update_alias'] = [];
// Fields that can be used in URL patterns to define hierarchy.
$GLOBALS['dt_core_parent_fields'] = [
  'field_core_parent',
  'field_core_policy_area',
  'field_core_policy_areas',
];

include_once 'dt_core.features.inc';

/**
 * No source field Exception.
 */
class DTCoreSourceFieldError extends Exception {
}

/**
 * No destionation field Exception.
 */
class DTCoreDestinationFieldError extends Exception {
}

/**
 * Fields are of same tye Exception.
 */
class DTCoreFieldTypeAreNotSame extends Exception {
}

/**
 * Circular reference Exception.
 */
class DTCoreParentCircular extends Exception {
}

/**
 * Implements hook_field_widget_form_alter().
 */
function dt_core_field_widget_form_alter(&$element, &$form_state, $context) {
  if ($context['field']['type'] == 'entityreference') {
    if ($context['field']['settings']['target_type'] == 'node' && !empty($context['field']['settings']['handler_settings']['target_bundles'])) {
      $types = array_intersect($context['field']['settings']['handler_settings']['target_bundles'], array_keys(node_type_get_types()));
      $types_count = count($types);
      $links = '';
      $i = 0;
      $separator = ',';
      foreach ($types as $machine_name) {
        $type = node_type_get_type($machine_name);
        $current_separator = $types_count > 1 && $i == $types_count - 2 ? ' ' . t('or') : $separator;
        $links .= l($type->name, 'node/add/' . str_replace('_', '-', $machine_name), array('attributes' => array('target' => '_blank'))) . $current_separator . ' ';
        $i++;
      }
      $links = rtrim($links, $separator . ' ');
      $description = '<p>' . t('In case the content you try to refer to does not exist yet you can create it by going to !links.', array('!links' => $links)) . '</p>';
      if (isset($element['target_id'])) {
        $element['target_id']['#description'] = $description . $element['target_id']['#description'];
      }
      else {
        $element['#description'] = $description . $element['#description'];
      }
    }
  }
}

/**
 * Implements hook_block_info().
 */
function dt_core_block_info() {
  $blocks['dt_header_site_tab_switcher'] = array(
    'info' => t('Header site tab switcher'),
  );

  $blocks['dt_footer_site_tab_switcher'] = array(
    'info' => t('Footer site tab switcher'),
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function dt_core_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'dt_header_site_tab_switcher':
    case 'dt_footer_site_tab_switcher':
      $block['content'] = _dt_core_get_blocks_content($delta);
      break;
  }
  return $block;
}

/**
 * A module-defined block content function.
 *
 * @param string $delta
 *   The delta.
 *
 * @return array
 *   Result to be rendered.
 */
function _dt_core_get_blocks_content($delta) {
  $result = array();
  switch ($delta) {
    case 'dt_header_site_tab_switcher':
      $result = array(
        '#markup' => theme('site_switcher_tabs', array('modifier' => 'site-switcher--header')),
      );
      break;

    case 'dt_footer_site_tab_switcher':
      $result = array(
        '#markup' => theme('site_switcher_tabs', array('modifier' => 'site-switcher--footer')),
      );
      break;
  }
  return $result;
}

/**
 * Implements hook_theme().
 */
function dt_core_theme($existing, $type, $theme, $path) {
  return array(
    'site_switcher_tabs' => array(
      'file' => 'dt_core.theme.inc',
      'variables' => array(
        'modifier' => NULL,
      ),
    ),
  );
}

/**
 * Helper to add initial set of buttons on the default profile of the Full HTML.
 */
function _dt_apply_wysiwyg_buttons() {
  // Enable a set of CKEditor buttons for DT project on the "Full HTML" profile.
  $default = array(
    'Anchor',
    'Bold',
    'Italic',
    'Underline',
    'Format',
    'JustifyBlock',
    'JustifyCenter',
    'JustifyLeft',
    'JustifyRight',
    'Indent',
    'Outdent',
    'Blockquote',
    'Font',
    'Table',
    'BulletedList',
    'NumberedList',
    'Link',
    'Unlink',
    'Source',
    'PasteFromWord',
    'Undo',
    'ShowBlocks',
  );
  multisite_config_service('wysiwyg')->addButtonsToProfile('full_html', 'default', $default);

  $lite = array(
    'lite_AcceptAll',
    'lite_RejectOne',
    'lite_RejectAll',
    'lite_ToggleShow',
    'lite_AcceptOne',
    'lite_ToggleTracking',
  );
  multisite_config_service('wysiwyg')->addButtonsToProfile('full_html', 'lite', $lite);
}

/**
 * Implements function hook_path_insert().
 */
function dt_core_path_insert($path) {
  _dt_core_path_update_relatives($path);
}

/**
 * Implements function hook_path_update().
 */
function dt_core_path_update($path) {
  _dt_core_path_update_relatives($path);
}

/**
 * Updates aliases of parent | child nodes.
 *
 * @param array $path
 *   The array containing path information.
 */
function _dt_core_path_update_relatives($path) {
  $source = explode('/', $path['source']);
  if ($source[0] == 'node') {
    $nid = $source[1];

    foreach ($GLOBALS['dt_core_parent_fields'] as $field_name) {
      // Find children based on field.
      $children = _dt_core_node_get_relatives($nid, $field_name);
      // Add current as first to force re-generate as first.
      if (!empty($parents)) {
        array_unshift($children, $nid);
      }

      // Find parents based on field.
      $parents = _dt_core_node_get_relatives($nid, $field_name, 'parents', TRUE);
      // Add current as last to force re-generate as last.
      if (!empty($parents)) {
        $parents[] = $nid;
      }

      $relatives = array_merge($parents, $children);
      if (!empty($relatives)) {
        $GLOBALS['dt_core_nodes_to_update_alias'][$nid] = $relatives;
      }
    }
  }
}

/**
 * Finds child|parent nodes based on entity reference.
 *
 * Only a few entity reference fields can be used to define parent relationship.
 * These fields are stored in the $GLOBALS['dt_core_parent_fields'].
 *
 * @param int $nid
 *   Node id.
 * @param string $field_name
 *   Field name that is used for hierarchy.
 * @param string $direction
 *   Children or parents.
 * @param bool $no_alias_only
 *   Exclude nodes that already have an alias.
 * @param int $original_nid
 *   Node id of the starting item.
 *
 * @return array
 *   Node ids of children|parents
 *
 * @see $GLOBALS['dt_core_parent_fields']
 */
function _dt_core_node_get_relatives($nid, $field_name, $direction = 'children', $no_alias_only = FALSE, $original_nid = NULL) {
  if (!isset($field_name) || !field_info_field($field_name)) {
    return array();
  }
  $original_nid = !$original_nid ? $nid : $original_nid;
  $affected_nodes = array();

  if ($direction == 'parents') {
    $result = db_select('field_data_' . $field_name, 'p')
      ->fields('p', array($field_name . '_target_id'))
      ->condition('entity_id', $nid, '=')
      ->condition('delta', '0', '=')
      ->execute()
      ->fetchAssoc();

    $nids = $result ? array_values($result) : FALSE;
    // Check if parent has already an alias.
    if ($nids) {
      if ($no_alias_only && drupal_get_path_alias('node/' . $nids[0]) != ('node/' . $nids[0])) {
        return array();
      }

      // Item is among its own parents.
      if (in_array($original_nid, $nids)) {
        throw new DTCoreParentCircular(
          t('Node !nid is among its own parents', array(
            '!nid' => $original_nid,
          ))
        );
      }
    }
  }
  // Children need to be updated always.
  else {
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->fieldCondition($field_name, 'target_id', $nid, '=');

    $result = $query->execute();
    $nids = isset($result['node']) ? array_keys($result['node']) : FALSE;

    // Item is among its own children.
    if ($nids && in_array($original_nid, $nids)) {
      throw new DTCoreParentCircular(
        t('Node !nid is among its own children', array(
          '!nid' => $original_nid,
        ))
      );
    }
  }

  if ($nids) {
    foreach ($nids as $ref_nid) {
      if (isset($result['node'][$ref_nid])) {
        // URL pattern for node type.
        $pattern = pathauto_pattern_load_by_entity('node', $result['node'][$ref_nid]->type);
        // If current child URL is not using the field in alias pattern, skip.
        if (!_dt_core_parent_field_in_pattern($field_name, $pattern)) {
          continue;
        }
      }

      // Find relatives.
      $referenced = _dt_core_node_get_relatives($ref_nid, $field_name, $direction, $no_alias_only, $original_nid);
      // Add the to the list in the appropriate order based on direction.
      if ($direction == 'parents') {
        $affected_nodes = array_merge($affected_nodes, $referenced);
        $affected_nodes[] = $ref_nid;
      }
      else {
        $affected_nodes[] = $ref_nid;
        $affected_nodes = array_merge($affected_nodes, $referenced);
      }
    }
  }

  return $affected_nodes;
}

/**
 * Implements function hook_exit().
 */
function dt_core_exit() {
  if (empty($GLOBALS['dt_core_nodes_to_update_alias']) || !is_array($GLOBALS['dt_core_nodes_to_update_alias'])) {
    return;
  }

  $nids_to_update = $GLOBALS['dt_core_nodes_to_update_alias'];
  $GLOBALS['dt_core_nodes_to_update_alias'] = array();
  foreach ($nids_to_update as $nid => $relatives) {
    // Paths update using the update method of the pathauto module.
    // Doing it one by one instead of using
    // pathauto_node_update_alias_multiple() to keep the order of items intact.
    foreach ($relatives as $rel_nid) {
      $node = node_load($rel_nid);
      pathauto_node_update_alias($node, 'update');
    }
  }
}

/**
 * Implements hook_pathauto_alias_alter().
 */
function dt_core_pathauto_alias_alter(&$alias, array &$context) {
  // Remove duplicates that are a result of a prefix defined in th URL pattern.
  // before the parent fields slug.
  //
  // For example:
  // The pattern "prefix/[parent:url]/[title]" might result in an alias like
  // "prefix/prefix/parent-title/title" if parent is of the same type since the
  // prefix is added twice. We will remove the duplicate prefix now.
  // We consider everything before the first token a prefix.
  $pattern_prefix = explode('[', $context['pattern']);
  $prefix = $pattern_prefix[0];

  if (!empty($prefix)) {
    // Check if it is subject of parent field.
    foreach ($GLOBALS['dt_core_parent_fields'] as $field_name) {
      // If the URL pattern does rely on this field remove duplicate prefix.
      if (_dt_core_parent_field_in_pattern($field_name, $context['pattern'])) {
        $alias = str_replace($prefix . $prefix, $prefix, $alias);
      }
    }
  }
}

/**
 * Checks if a URL pattern is relying on a parent field.
 *
 * @param string $field_name
 *   Field name.
 *
 * @return mixed
 *   string pattern token segment | bool FALSE
 */
function _dt_core_parent_field_in_pattern($field_name, $pattern) {
  // Check if URL pattern uses parent's URL.
  $pattern_segment = 'node:' . str_replace('_', '-', $field_name) . '(:0)?:url:path';
  if (preg_match('/' . $pattern_segment . '/', $pattern)) {

    return $pattern_segment;
  }

  return FALSE;
}

/**
 * Implements hook_node_validate().
 */
function dt_core_node_validate($node, $form, &$form_state) {
  foreach ($GLOBALS['dt_core_parent_fields'] as $field_name) {
    if (isset($form_state['values'][$field_name][LANGUAGE_NONE][0]['target_id']) && !empty($form_state['values'][$field_name][LANGUAGE_NONE][0]['target_id'])) {
      $parent = $form_state['values'][$field_name][LANGUAGE_NONE][0]['target_id'];

      // Detect if node has been set as its own parent.
      if ($parent == $node->nid) {
        form_set_error($field_name, t('The page cannot be its own parent!'));
      }
      // Detect circular reference between two nodes.
      if (_dt_core_detect_circular_reference($node->nid, $parent)) {
        form_set_error($field_name, t('There is a circular reference between this page and one of its parent!'));
      }
    }
  }
}

/**
 * Checks if a URL pattern is relying on a parent field.
 *
 * @param int $nid
 *   Node ID.
 * @param int $parent_nid
 *   Parent node ID.
 *
 * @return bool
 *   There is a circular reference between the two nodes.
 */
function _dt_core_detect_circular_reference($nid, $parent_nid) {
  $relatives = array();
  try {
    foreach ($GLOBALS['dt_core_parent_fields'] as $field_name) {
      // Look for relatives of the future parent.
      $relatives += _dt_core_node_get_relatives($parent_nid, $field_name, $direction = 'parents');
    }
  }
  catch (DTCoreParentCircular $e) {

    return TRUE;
  }
  // Check if our node is among its future relatives.
  return in_array($nid, $relatives);
}

/**
 * Helper function for creating a taxonomy term in a vocabulary.
 *
 * @param string $vocabulary_machine_name
 *   Vocabulary machine name.
 * @param string $term_name
 *   Added term.
 *
 * @return bool
 *   Return TRUE if the taxonomy term was created.
 */
function _dt_core_create_taxonomy_term($vocabulary_machine_name, $term_name) {
  // Check the vocabulary if exist.
  if ($vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_machine_name)) {
    // Creating term.
    $term = array();
    $term['vocabulary_machine_name'] = $vocabulary_machine_name;
    $term['vid'] = $vocabulary->vid;
    $term['name'] = $term_name;
    // Save term as an entity.
    $entity = entity_create('taxonomy_term', $term);
    return entity_save('taxonomy_term', $entity);
  }
  return FALSE;
}

/**
 * Migrate existing field content from language "undefined" to entity language.
 *
 * @param string $field_name
 *   Field to enable entity translation on.
 */
function _dt_core_enable_entity_translation($field_name, &$sandbox) {
  $context = array('sandbox' => &$sandbox);
  module_load_include('inc', 'entity_translation', 'entity_translation.admin');
  entity_translation_translatable_switch(TRUE, $field_name);
  entity_translation_translatable_batch(TRUE, $field_name, TRUE, $context);
  $sandbox['#finished'] = $context['finished'];
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function dt_core_form_locale_languages_overview_form_alter(&$form, &$form_state) {
  // Increase the range of weights that can be assigned to languages in the
  // languages overview form. By default the languages can only be sorted using
  // the range -10 to +10 but since we have 24 languages this is not sufficient.
  foreach (element_children($form['weight']) as $key) {
    $form['weight'][$key]['#delta'] = 20;
  }
}

/**
 * Helper function to enable languages.
 *
 * @param array $languages
 *   Language codes of languages to be enabled.
 */
function _dt_core_enable_languages($languages = array()) {
  module_load_include('inc', 'locale', 'locale.admin');
  $form_state = array();
  foreach ($languages as $key => $langcode) {
    // Enable language.
    multisite_config_service('locale')->addLanguage($langcode);
    // Set the appropriate weight for languages to follow the order defined in
    // the array.
    $form_state['values']['weight'][$langcode] = -20 + $key;

    // Portuguese exception:
    // In Drupal the "pt" prefix belongs to Portuguese / International but we
    // need Portuguese / Portugal to have this prefix (theme_image_style has
    // "pt-pt" as default prefix). We need to change this to "pt".
    if ($langcode == 'pt-pt') {
      db_update('languages')
        ->fields(array(
          'name' => 'Portuguese',
          'prefix' => 'pt',
        ))
        ->condition('language', $langcode)
        ->execute();
    }
  }
  // Save the order through the original form.
  drupal_form_submit('locale_languages_overview_form', $form_state);
  // Enable URL suffix based language negotiation.
  multisite_config_service('locale')->setLanguageNegotiation('nexteuropa_multilingual_url_suffix');
  // Fix lowercase languages.
  _dt_core_transform_language_to_lower_case(_dt_core_lower_case_languages());
}

/**
 * Implements hook_node_presave().
 *
 * If a whitespace has been entered after a title, we remove it.
 */
function dt_core_node_presave($node) {
  $node->title = rtrim($node->title);
}

/**
 * Implements hook_context_load_alter().
 */
function dt_core_context_load_alter(&$context) {
  if ($context->name == 'dt_core_non_homepage_pages') {
    if ($node = menu_get_object('node')) {
      global $language;
      $interface_language = $language->language;
      $content_languages = $node->translations->data;

      if (array_key_exists($interface_language, $content_languages)) {
        unset($context->reactions['block']['blocks']['language_selector_page-language_selector_page']);
      }
    }
  }
}

/**
 * Removes maxlength configuration from field.
 */
function _dt_core_disable_maxlength($element) {
  // Check if we are translating and maxlength for field is enabled.
  if (isset($element['#field_name']) && isset($element['#maxlength']) && isset($element['#language']) && isset($element['#entity']) && isset($element['#entity']->language) && $element['#language'] !== $element['#entity']->language) {
    // Remove maxlength.
    unset($element['#maxlength']);
  }

  return $element;
}

/**
 * Implements hook_element_info_alter().
 */
function dt_core_element_info_alter(&$cache) {
  $cache['textarea']['#process'][] = '_dt_core_disable_maxlength';
  $cache['textfield']['#process'][] = '_dt_core_disable_maxlength';
}

/**
 * Helper function to return a list of languages that should be enabled.
 *
 * Languages that will be enabled. The order they need to appear when listed is
 * defined here:
 * @link http://publications.europa.eu/code/en/en-370200.htm.
 *
 * @return array
 *   List of languages.
 */
function _dt_core_ec_official_languages() {
  return array(
    'bg',
    'cs',
    'da',
    'de',
    'et',
    'el',
    'en',
    'es',
    'fr',
    'ga',
    'hr',
    'it',
    'lv',
    'lt',
    'hu',
    'mt',
    'nl',
    'pl',
    'pt-pt',
    'ro',
    'sk',
    'sl',
    'fi',
    'sv',
  );
}

/**
 * Helper function to return a list of languages that need to be lower case.
 *
 * @return array
 *   List of languages that need to be lower case.
 */
function _dt_core_lower_case_languages() {
  return array(
    'bg',
    'cs',
    'da',
    'et',
    'el',
    'es',
    'fr',
    'hr',
    'lv',
    'lt',
    'hu',
    'pl',
    'pt-pt',
    'ro',
    'sk',
    'sl',
    'fi',
    'sv',
  );
}

/**
 * Helper function to transform language names to lower case.
 *
 * @param array $language_codes
 *   List of language codes.
 *
 * @return bool
 *   TRUE/FALSE.
 */
function _dt_core_transform_language_to_lower_case(array $language_codes) {
  // Ininitialize our return value.
  $return = TRUE;

  // Loop the results and update the langcode.
  foreach ($language_codes as $langcode) {
    // Our update query, this either returns TRUE or FALSE.
    $query = db_update('languages')
      ->expression('native', 'LCASE(native)')
      ->condition('language', $langcode)
      ->execute();

    // If there were no issues, we show a message that everything went well. In
    // other cases notifiy about the error, and make the function return FALSE.
    if ($query) {
      // Create our log message.
      $watchdog_content = array(
        'message' => 'Language %langcode updated to lower case.',
        'type' => WATCHDOG_INFO,
        'replacement' => array('%langcode' => $langcode),
      );
    }
    else {
      // Create our log message.
      $watchdog_content = array(
        'message' => 'Could not update language %langcode to lower case. This might come due to the fact the language is not yet available or it already is updated.',
        'type' => WATCHDOG_WARNING,
        'replacement' => array('%langcode' => $langcode),
      );
      // We had one error, but we can finish other querys. Set our return
      // parameter to false, so that we can continue the query and return false
      // afterwards.
      $return = FALSE;
    }

    // Watchdog our log message.
    watchdog('dt_core', $watchdog_content['message'], $watchdog_content['replacement'], $watchdog_content['type']);
  }

  // Retrun our outcome.
  return $return;
}

/**
 * Implements hook_views_query_alter().
 *
 * To avoid reconfiguring our views we simply remove our sort field from the
 * query. This query alteration, takes in consideration that we have a maximum
 * of 3 possible languages. It joins the translated data.
 */
function dt_core_views_query_alter(&$view, &$query) {
  // If it is one of our listings.
  if (isset($view->sort['title_field_value'])) {
    // Get our languages.
    $fallback_languages = _dt_shared_functions_content_language_order();
    // Sort direction from our sort.
    $sort_direction = 'ASC';

    // If the sort direction is set we use the set one.
    if (isset($view->sort['title_field_value']->options['order'])) {
      $sort_direction = $view->sort['title_field_value']->options['order'];
    }

    // Language subquerys.
    $or = db_or();

    // Also we can add our sorting function here. So lets start with the
    // ininitialization of that variable.
    $order_by_case = 'CASE ';
    // Add these languages to the query.
    foreach ($fallback_languages as $key => $fallback_language) {
      $or->condition('title_field.language', $fallback_language);
      $order_by_case .= 'WHEN title_field.language = \'' . $fallback_language . '\' THEN ' . $key . ' ';
    }
    $order_by_case .= 'END';

    // Build our sub query.
    $sub_query = db_select('field_data_title_field', 'title_field');
    $sub_query->addField('title_field', 'title_field_value', 'translated_title');
    $sub_query->addField('title_field', 'entity_id', 'translated_id');
    $sub_query->addField('title_field', 'language');
    $sub_query->addExpression($order_by_case);
    $sub_query->condition($or);

    // Create new join object.
    $join = new views_join();
    $join->definition = array(
      'table formula' => $sub_query,
      'left_field' => 'nid',
      'field' => 'translated_id',
      'left_table' => 'node',
    );
    $join->left_table = 'node';
    $join->field = 'translated_id';
    $join->left_field = 'nid';
    $join->type = 'LEFT';
    // This will make sure that we only use the first and best translation
    // match. Because the order by case is the same, a simple string replace is
    // enough to make it work.
    $join->extra = 'title_field.expression = (SELECT Min(' . str_replace('title_field.language', 'language', $order_by_case) . ') FROM field_data_title_field WHERE entity_id = title_field.translated_id)';

    // Do the actual join.
    $query->table_queue['title_field'] = array(
      'alias' => 'title_field',
      'table' => $sub_query,
      'relationship' => 'node',
      'join' => $join,
    );

    // Replace the title sort fields with our custom.
    foreach ($query->orderby as $key => &$value) {
      if ($value['field'] == 'field_data_title_field_title_field_value') {
        $value['field'] = 'title_field.translated_title';
        break;
      }
    }

    // Change our where condition using the title field to use the translated
    // title field. So, when the condition is using the title field, we replace
    // it to use the translated title value instead.
    foreach ($query->where as &$where) {
      foreach ($where['conditions'] as &$condition) {
        $condition['field'] = str_replace('field_data_title_field.title_field_value', 'translated_title', $condition['field']);
      }
    }

    // This is originally coming from our sort, we could even delete this part
    // once we move to a better solution. As we replace the sorting logic, we
    // have to unset these, as they are causing the duplicate results.
    if (isset($query->table_queue['field_data_title_field'])) {
      unset($query->table_queue['field_data_title_field']);
    }
    // Remove the field.
    if (isset($query->fields['field_data_title_field_title_field_value'])) {
      unset($query->fields['field_data_title_field_title_field_value']);
    }
  }
}

/**
 * Helper function to get plurial names.
 *
 * This should move to the dt_node_settings module.
 *
 * @param string $bundle
 *   The name of the bundle to get the plurial name.
 */
function _dt_core_get_plurial_content_types($bundle) {
  // Forming plurals for existing content types.
  $plurals = array(
    'announcement' => t("announcements"),
    'page' => t("pages"),
    'contact' => t("contacts"),
    'department' => t("departments"),
    'editorial_team' => t("editorial teams"),
    'file' => t("files"),
    'basic_page' => t("pages"),
    'person' => t("people"),
    'policy' => t("policies"),
    'policy_area' => t("policy areas"),
    'policy_implementation' => t("policy implementations"),
    'policy_input' => t("policy inputs"),
    'policy_keyfile' => t("policy key files"),
    'priority' => t("priorities"),
    'publication' => t("publications"),
    'class' => t("classes"),
    'topic' => t("topics"),
    'toplink' => t("top links"),
  );

  $singular = node_type_get_name($bundle);
  // If user preference for plural form - use it, otherwise use the label.
  if (isset($plurals[$bundle])) {
    $plural = $plurals[$bundle];
  }
  else {
    $plural = strtolower(t("@bundles", array('@bundle' => $singular)));
  }

  $forms = array(
    'singular' => strtolower($singular),
    'plural' => $plural,
  );

  return $forms;
}

/**
 * Implements hook_preprocess_views_view().
 *
 * This was in the informational template before. But moved it here because we
 * need it on multiple templates that use dt_core.
 */
function dt_core_preprocess_views_view(&$variables) {
  $view = $variables['view'];
  if (isset($view->filter['type'])) {
    $content_type_filters = $view->filter['type']->value;
    // The first element of the array is the right type of filter.
    $content_type = reset($content_type_filters);

    $variables['items_count'] = '';

    if ((in_array('listing', $variables['classes_array'])) || $view->style_plugin->plugin_name == 'nexteuropa_bem_listing' && isset($view->exposed_data)) {
      // Calculate the number of items displayed in a view listing.
      $total_rows = !$view->total_rows ? count($view->result) : $view->total_rows;

      $content_type_forms = _dt_core_get_plurial_content_types($content_type);

      $variables['items_count'] = format_plural($total_rows, $content_type_forms['singular'], $content_type_forms['plural']) . ' (' . $total_rows . ')';
    }
  }
}

/**
 * Implements hook_ds_fields_info().
 */
function dt_core_ds_fields_info($entity_type) {
  $fields = array();

  $fields['sticky_label'] = array(
    'title' => t('Sticky label'),
    'field_type' => DS_FIELD_TYPE_FUNCTION,
    'function' => '_dt_core_ds_fields_stick_label',
  );

  return array('node' => $fields);
}

/**
 * Custom function for single token replacement in a field.
 */
function _dt_core_ds_fields_stick_label($field) {
  if (isset($field['entity']->sticky) && $field['entity']->sticky) {
    return '<span class="label label--highlight label--meta">' . t('Highlight') . '</span>';
  }
}

/**
 * Implements hook_metatag_metatags_view_alter().
 *
 * Because of SEO recommendations, description meta tag
 * should't be more than 155 characters.
 * + og:description meta tag should have the same text as
 * description meta tag.
 * If description metatag does not exist then it will fall back
 * to og:description with character's count already limited.
 */
function dt_core_metatag_metatags_view_alter(&$output, $instance, $options) {
  // Metatag: description.
  if (isset($output['description']['#attached']['drupal_add_html_head'][0][0]['#value'])) {
    $output['description']['#attached']['drupal_add_html_head'][0][0]['#value']
      = truncate_utf8($output['description']['#attached']['drupal_add_html_head'][0][0]['#value'], 152, TRUE, TRUE);
  }
  // Metatag: og:description.
  if (isset($output['og:description']['#attached']['drupal_add_html_head'][0][0]['#value'])) {
    $output['og:description']['#attached']['drupal_add_html_head'][0][0]['#value']
      = (isset($output['description']['#attached']['drupal_add_html_head'][0][0]['#value'])) ?
      $output['description']['#attached']['drupal_add_html_head'][0][0]['#value'] :
      truncate_utf8($output['og:description']['#attached']['drupal_add_html_head'][0][0]['#value'], 152, TRUE, TRUE);
  }
  // We use an alter hook instead of the features configuration to avoid
  // overrides in the features.
  if (isset($output['date']['#attached']['drupal_add_html_head'][0][0]['#value'])) {
    if (isset($options['entity_type']) && $options['entity_type'] == 'node') {
      // Our token.
      $token = '[dt_tokens:dt_publish_date]';
      // Replaced.
      $token_replaced = token_replace($token, array('node' => $options['entity']));
      // Make sure that it has been replaced.
      $replaced = !strpos($token_replaced, $token);
      // Only when we have successfully replaced te token, we add it to our meta
      // tag. In other cases we dont do anything with it.
      if ($replaced) {
        $output['date']['#attached']['drupal_add_html_head'][0][0]['#value'] = $token_replaced;
      }
    }
  }
}

/**
 * Helper function to get the system path of aliased links.
 *
 * @param string $link
 *   The link to be handled.
 *
 * @return string
 *   The link, revisited.
 */
function _dt_core_menu_link($link, $lang = FALSE) {
  global $base_url;
  $lang = $lang ? $lang : LANGUAGE_NONE;
  if ($link != '<front>' &&  $link != '<nolink>') {
    $source = drupal_lookup_path('source', $link, $lang);
    if (!$source) {
      $view = drupal_valid_path($link);
      if ($view) {
        return $link;
      }
      else {
        $link = url($link, array('absolute' => TRUE));
      }
    }
    else {
      $link = $source;
    }
  }

  return $link;
}

/**
 * Create menu links.
 *
 * @param string $menu
 *   Menu name.
 * @param string $link
 *   The raw link.
 * @param string $plid
 *   The parent item mlid.
 * @param string $title
 *   The link title.
 * @param string $module
 *   Module machine name.
 * @param string $weight
 *   Weight of the menu item.
 * @param string $lang
 *   Lang code sanitized.
 * @param string $tsid
 *   Translations set id.
 * @param string $nolink
 *   Items without links.
 * @param string $logs
 *   The logs directory path.
 *
 * @return int
 *   The mlid of the created menu item.
 */
function _dt_core_menu_item($menu, $link, $plid, $title, $module, $weight, $lang = 'en', $tsid = NULL, $nolink = FALSE, $logs = FALSE) {
  $link = _dt_core_menu_link($link, $lang);
  $plid = ($plid > 0) ? $plid : 0;

  $item = array(
    'menu_name' => $menu,
    'module' => $module,
    'customized' => 1,
    'language' => $lang,
    'plid' => $plid,
    'enabled' => 1,
    'expanded' => 1,
    'link_path' => $link,
    'locked' => TRUE,
    'link_title' => $title,
    'hidden' => 0,
    'weight' => $weight,
    'i18n_menu' => 1,
    'options' => array('title' => $link),
  );

  menu_link_save($item);

  return $item['mlid'];

}

/**
 * Helper function to get the mlid basing on the link name.
 *
 * @param string $name
 *   Name of the menu item.
 * @param string $menu
 *   Name of the menu.
 *
 * @return bool/int
 *   False or menu id.
 */
function _dt_core_menu_item_name_get($name, $menu) {
  $mlid = db_select('menu_links', 'ml')
    ->fields('ml', array('mlid'))
    ->condition('link_title', $name)
    ->condition('menu_name', $menu)
    ->execute()
    ->fetchField();

  if (is_numeric($mlid)) {
    return $mlid;
  }
  else {
    return FALSE;
  }
}
